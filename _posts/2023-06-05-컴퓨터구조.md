---
layout: post
title: 명령어의 구조
image: computer_architecture_logo.png
excerpt: 명령어의 구조
categories: 컴퓨터구조
category: 컴퓨터구조
tags: [컴퓨터구조, 명령어구조, 연산코드, 오퍼랜드, 주소지정방식]
---

**명령어**는 연산 코드와 오퍼랜드로 구성되어 있다.  

![1](https://github.com/DaYoung-woo/DaYoung-woo.github.io/assets/131967254/afb217ae-27a8-4ee9-a2f4-99124e901143)  

![2](https://github.com/DaYoung-woo/DaYoung-woo.github.io/assets/131967254/23efc2a6-7e3c-4838-ab85-8d0fd9bdfa79)  

왼쪽 파란색 부분은 명령어가 수행할 연산이 담긴 연산 코드이다.  
연산 코드는 연산자라고도 불리며, 연산 코드가 담기는 부분을 연산 코드 필드라고 부른다.  

오른쪽 회색 부분은 연산에 사용할 데이터 또는 연산에 사용할 데이터가 저장된 위치가 담긴 오퍼랜드이다.  
오퍼랜드는 피연산자라고도 불리며, 오퍼랜드가 담기는 영역을 오퍼랜드 필드라고 한다.  

### 오퍼랜드
오퍼랜드에는 숫자와 문자 등을 나타내는 데이터나 메모리/레지스터 주소가 올 수 있다.  
주소 값이 들어가는 경우가 많아서 주소 필드라고 부르기도 한다.  
명령어 안에 오퍼랜드는 없을 수도 있고 여러 개가 존재할 수도 있다.  

오퍼랜드가 없는 경우(0-주소 명령어)  
![3](https://github.com/DaYoung-woo/DaYoung-woo.github.io/assets/131967254/ef2c719d-70e4-494a-97f9-5d58eccee4ad)  
<br/>

오퍼랜드가 1개인 경우(1-주소 명령어)  
![4](https://github.com/DaYoung-woo/DaYoung-woo.github.io/assets/131967254/993df9ba-99b7-40f7-99de-03d864daabc2)  
<br/>

오퍼랜드가 2개인 경우(2-주소 명령어)  
![5](https://github.com/DaYoung-woo/DaYoung-woo.github.io/assets/131967254/19124ee5-11a7-4227-b43e-ab5757e475a9)  
<br/>

오퍼랜드가 3개인 경우(3-주소 명령어)  
![6](https://github.com/DaYoung-woo/DaYoung-woo.github.io/assets/131967254/0f75f166-73aa-41e3-bcff-e1d4078793bd)  

---

### 연산 코드 
연산코드는 명령어가 수행할 연산을 의미하는데 가장 기본적인 연산 코드 유형은 4가지로 구분할 수 있다.  

1. 데이터 전송  
2. 산술/논리 연산  
3. 제어 흐름 변경  
4. 입출력 제어  
<br/>

#### 데이터 전송
MOVE: 데이터를 옮겨라  
STORE: 메모리에 저장하라
LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라
PUSH: 스택에 데이터를 저장하라
POP: 스택의 최상단 데이터를 가져와라
<br/>

#### 산술/논리 연산
ADD / SUBSTACT / MULTIPLY / DEVIDE: 덧셈/뺄셈/곱셈/나눗셈을 수행하라  
INCREMENT / DECREMENT: 오퍼랜드에 1을 더하라/ 1을 빼라  
AND / OR / NOT: AND/OR/NOT 연산을 수행하라  
COMPARE: 두 개의 숫자 또는 TRUE/FALSE 값을 비교하라  
<br/>

#### 제어 흐름 변경
JUMP: 특정 주소로 실행 순서를 옮겨라  
CONDITIONAL JUMP: 조건에 부합할 떄 특정 주소로 실행 순서를 옮겨라  
HALT: 프로그램의 실행을 멈춰라  
CALL: 되돌아올 주소를 지정할 채 특정 주소로 실행 순서를 옮겨라  
RETURN: CALL을 호출할 떄 저장했던 주소로 돌아가라  
<br/>

#### 입출력 제어
READ(INPUT): 특정 입출력 장치로부터 데이터를 읽어라  
WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라  
START IO: 입출력 장치를 시작하라  
TEST IO: 입출력 장치의 상태를 확인하라  

---

### 주소 지정 방식
오퍼랜드 필드에 데이터가 저장된 위치를 명시할 떄 연산에 사용할 데이터 위치를 찾는 방법  

n비트의 명령어에서 연산 코드 필드가 m비트라면 오퍼랜드 필드의 크기는 n-m비트이다.  
명령어의 길이의 제약떄문에 오퍼랜드 필드 안에 크기가 초과되어 원하는 데이터를 넣지 못하는 경우가 생긴다.
이럴 경우를 방지하기 위해 다른 메모리 주소에 데이터를 넣고 그 주소를 오퍼랜드 필드 안에 넣는다.

16비트의 명령어에 연산 필트가 4비트인 경우,   
2-주소 명령어에서 오퍼랜드당 6비트가 할당된다.
하나의 오퍼랜드로 표현할 수 있는 정보의 가짓수는 2의 6제곱 = 64이다.

![7](https://github.com/DaYoung-woo/DaYoung-woo.github.io/assets/131967254/e6a04964-2699-448e-9a5e-eb64a0ae5381)
<br />

3-주소 명령어에서 오퍼랜드당 4비트가 할당된다.
하나의 오퍼랜드로 표현할 수 있는 정보의 가짓수는 2의 4제곱 = 16이다.
![8](https://github.com/DaYoung-woo/DaYoung-woo.github.io/assets/131967254/439e456e-e3c0-414b-a650-db4b60c8c9d2)
<br />

하지만 오퍼랜드 필드 안에 메모리나 레지스터의 주소를 명시한다면 그 메모리/레지스터의 크기만큼 표현할 수 있는 정보의 가짓수가 훨씬 커진다.  
![9](https://github.com/DaYoung-woo/DaYoung-woo.github.io/assets/131967254/16bea784-2c3e-4da9-865a-f43ac87846f7)
